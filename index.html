<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mappa 3D con Avatar ‚Äì Ottimizzata</title>

  <!-- Mapbox GL JS -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

  <!-- THREE.js (versione compatibile con Threebox 2.2.x) -->
  <script src="https://unpkg.com/three@0.122.0/build/three.min.js"></script>

  <!-- Threebox -->
  <link href="https://cdn.jsdelivr.net/gh/jscastro76/threebox@v.2.2.2/dist/threebox.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/gh/jscastro76/threebox@v.2.2.2/dist/threebox.min.js"></script>

  <style>
    :root {
      --panel-bg: rgba(255,255,255,.9);
      --shadow: 0 2px 6px rgba(0,0,0,.2);
      --radius: 12px;
      --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      
      /* Dimensioni responsive */
      --button-size: clamp(36px, 5vw, 44px);
      --font-size-small: clamp(11px, 2vw, 12px);
      --font-size-normal: clamp(13px, 2.5vw, 14px);
      --padding-small: clamp(6px, 1.5vw, 8px);
      --padding-normal: clamp(8px, 2vw, 12px);
      --gap-small: clamp(8px, 1.5vw, 10px);
      --gap-normal: clamp(10px, 2vw, 15px);
    }
    
    *{box-sizing:border-box}
    body { margin: 0; font-family: var(--font); }
    #map { position: absolute; inset: 0; }

    .avatar-marker {
      background-image: url('https://cdn-icons-png.flaticon.com/512/149/149071.png');
      background-size: cover;
      width: clamp(30px, 5vw, 40px);
      height: clamp(30px, 5vw, 40px);
      border-radius: 50%;
      border: 2px solid #fff;
      box-shadow: var(--shadow);
      /* Transizione smooth per visibilit√† */
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    /* Loading spinner migliorato */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(4px);
    }
    
    .loading-overlay.active {
      display: flex;
    }
    
    .loading-content {
      text-align: center;
      color: white;
    }
    
    .spinner {
      border: 4px solid rgba(255,255,255,0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .loading-text {
      font-size: 16px;
      font-weight: 500;
    }
    
    .loading-progress {
      margin-top: 10px;
      font-size: 14px;
      opacity: 0.8;
    }

    /* Media query per schermi piccoli */
    @media (max-width: 768px) {
      .custom-controls {
        bottom: 10px !important;
        right: 10px !important;
        flex-direction: column !important;
        padding: var(--padding-small) !important;
      }
      
      .custom-controls button {
        font-size: 16px !important;
        padding: 6px !important;
        width: var(--button-size);
        height: var(--button-size);
      }
      
      .pitch-slider {
        width: 60px !important;
        height: 30px !important;
      }
      
      .top-right-controls {
        top: 10px !important;
        right: 10px !important;
        flex-direction: column !important;
        align-items: flex-end !important;
      }
      
      .direction-indicator {
        font-size: var(--font-size-small) !important;
        padding: var(--padding-small) !important;
        max-width: 150px !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
      }
      
      .status-indicator {
        top: 60px !important;
        right: 10px !important;
        max-width: 200px !important;
        font-size: var(--font-size-small) !important;
      }
      
      .debug-info {
        bottom: 70px !important;
        left: 10px !important;
        max-width: 250px !important;
        font-size: 10px !important;
      }
      
      .gps-controls {
        gap: var(--gap-small) !important;
      }
    }

    .custom-controls {
      position: absolute; 
      bottom: 20px; 
      right: 50px;
      display: flex; 
      gap: var(--gap-small); 
      align-items: center;
      background: var(--panel-bg);
      padding: var(--padding-small); 
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      z-index: 1000;
    }
    
    .custom-controls button {
      font-size: clamp(16px, 3vw, 18px); 
      padding: 4px 10px; 
      border: none;
      background: white; 
      border-radius: 8px; 
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .custom-controls button:hover {
      background: #f0f0f0;
    }
    
    .pitch-slider { 
      width: clamp(40px, 8vw, 60px); 
    }

    .top-right-controls {
      position: absolute; 
      top: 20px; 
      right: 20px;
      display: flex; 
      gap: var(--gap-small); 
      align-items: center; 
      z-index: 1000;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    
    .direction-indicator {
      background: rgba(0,0,0,.7); 
      color: #fff;
      padding: var(--padding-small) var(--padding-normal); 
      border-radius: 20px; 
      font-size: var(--font-size-normal); 
      font-weight: 600;
      backdrop-filter: blur(8px);
    }
    
    .home-button, .avatar-toggle {
      background: white; 
      border: none; 
      padding: var(--padding-small) var(--padding-normal); 
      font-size: var(--font-size-normal);
      border-radius: 10px; 
      box-shadow: var(--shadow); 
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .home-button:hover, .avatar-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0,0,0,.25);
    }

    .status-indicator {
      position: absolute; 
      top: 70px; 
      right: 20px;
      background: rgba(0,0,0,.85); 
      color:#fff; 
      padding: var(--padding-normal); 
      border-radius: 10px;
      font-size: var(--font-size-small); 
      z-index: 1000; 
      max-width: 260px;
      /* üÜï MODIFICA 3: Animazione fade in/out */
      transition: opacity 0.3s ease;
    }

    .gps-controls {
      position: absolute; 
      top: 20px; 
      left: 20px; 
      display: flex; 
      flex-direction: column; 
      gap: var(--gap-small); 
      z-index: 1000;
    }
    
    .gps-button, .visibility-button { 
      background: var(--panel-bg); 
      border: none; 
      padding: var(--padding-small) var(--padding-normal); 
      border-radius: 10px; 
      cursor: pointer; 
      box-shadow: var(--shadow);
      font-size: var(--font-size-normal);
      transition: all 0.2s;
    }
    
    .gps-button:hover, .visibility-button:hover {
      transform: translateX(2px);
    }
    
    .gps-button.active { 
      background: #4CAF50; 
      color: #fff; 
    }
    
    .visibility-button.hidden { 
      background: #ff9800; 
      color: #fff; 
    }

    .debug-info {
      position: absolute; 
      bottom: 20px; 
      left: 20px; 
      background: rgba(0,0,0,.85);
      color: #fff; 
      padding: var(--padding-normal); 
      border-radius: 10px; 
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: var(--font-size-small); 
      max-width: 320px; 
      z-index: 1000; 
      white-space: pre-line;
    }
    
    /* Classe per nascondere avatar/marker */
    .avatar-hidden {
      opacity: 0 !important;
      transform: scale(0.8) !important;
      pointer-events: none !important;
    }

    /* Performance indicator */
    .performance-indicator {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,.85);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 11px;
      font-family: monospace;
      z-index: 1000;
      display: none;
    }
    
    .performance-indicator.show {
      display: block;
    }

  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Loading overlay migliorato -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-content">
      <div class="spinner"></div>
      <div class="loading-text" id="loadingText">Caricamento avatar...</div>
      <div class="loading-progress" id="loadingProgress">0%</div>
    </div>
  </div>

  <div class="status-indicator" id="statusIndicator">Caricamento‚Ä¶</div>

  <div class="gps-controls">
    <button class="gps-button active" id="gpsToggle">üìç GPS ON</button>
    <button class="visibility-button" id="visibilityToggle">Visibilit√† ON</button>
  </div>

  <div class="top-right-controls">
    <button class="avatar-toggle" id="avatarToggle">üë§ 2D</button>
    <button class="avatar-toggle" id="buildingsToggle">üèôÔ∏è 3D On</button>
    <button class="home-button" id="goHome">üè†</button>
    <div class="direction-indicator" id="directionIndicator">N 0¬∞</div>
  </div>

  <div class="debug-info" id="debugInfo">Debug GPS: Caricamento‚Ä¶</div>

  <!-- üÜï MODIFICA 6: Performance monitor -->
  <div class="performance-indicator" id="performanceIndicator">
    FPS: 60 | Mem: 0 MB
  </div>

  <div class="custom-controls">
    <button id="zoomIn">+</button>
    <button id="zoomOut">‚àí</button>
    <input type="range" id="pitchSlider" min="0" max="85" value="60" class="pitch-slider">
  </div>

  <script>
    const CONFIG = {
      // Avatar
      AVATAR_URL: 'https://models.readyplayer.me/688490fba5d9e1a75b930b7a.glb',
      AVATAR_FALLBACK_URL: 'https://models.readyplayer.me/688490fba5d9e1a75b930b7a.glb',
      AVATAR_SCALE: 5,
      AVATAR_HEIGHT: 1.8,
      
      // GPS
      GPS_ACCURACY_THRESHOLD: 100, // metri
      GPS_MIN_MOVEMENT: 1, // metri
      GPS_UPDATE_DISTANCE: 50, // metri per aggiornare mappa
      EMA_ALPHA: 0.25, // smoothing
      
      // Performance
      TARGET_FPS: 60,
      ANIMATION_UPDATE_RATE: 1/60,
      IDLE_TIMEOUT: 1600, // ms
      
      // UI
      STATUS_AUTO_HIDE_DELAY: 2000, // ms
      TRANSITION_DURATION: 1600, // ms
      
      // Fallback location (Milano)
      DEFAULT_HOME: [0, 0]
    };

    mapboxgl.accessToken = 'pk.eyJ1IjoibWVldGdvLWJ1aWxkMDAiLCJhIjoiY21jcTFzdXV2MGQ0MzJscXc0MHc0Y2Q0ZSJ9.hFWnqVLwck_EoyBZGoxdxA';

    class PerformanceMonitor {
      constructor() {
        this.frames = [];
        this.lastTime = performance.now();
        this.enabled = false;
      }

      update() {
        if (!this.enabled) return;
        
        const now = performance.now();
        const delta = now - this.lastTime;
        this.lastTime = now;
        
        this.frames.push(delta);
        if (this.frames.length > 60) this.frames.shift();
        
        const avgDelta = this.frames.reduce((a, b) => a + b, 0) / this.frames.length;
        const fps = Math.round(1000 / avgDelta);
        
        // Memoria (se disponibile)
        const mem = performance.memory ? 
          (performance.memory.usedJSHeapSize / 1048576).toFixed(1) : 'N/A';
        
        const indicator = document.getElementById('performanceIndicator');
        indicator.textContent = `FPS: ${fps} | Mem: ${mem} MB`;
        
        // Warning se FPS basso
        if (fps < 30) {
          console.warn('‚ö†Ô∏è FPS basso:', fps);
        }
      }

      toggle() {
        this.enabled = !this.enabled;
        document.getElementById('performanceIndicator').classList.toggle('show', this.enabled);
      }
    }

    const perfMonitor = new PerformanceMonitor();

    class ResourceManager {
      constructor() {
        this.resources = new Set();
      }

      track(resource, disposeMethod = 'dispose') {
        this.resources.add({ resource, disposeMethod });
      }

      cleanup() {
        console.log('üßπ Pulizia risorse:', this.resources.size);
        this.resources.forEach(({ resource, disposeMethod }) => {
          try {
            if (resource && typeof resource[disposeMethod] === 'function') {
              resource[disposeMethod]();
            }
          } catch (e) {
            console.warn('Errore cleanup:', e);
          }
        });
        this.resources.clear();
      }
    }

    const resourceManager = new ResourceManager();

    // Cleanup automatico prima di chiudere
    window.addEventListener('beforeunload', () => {
      resourceManager.cleanup();
      if (window.__gpsWatchId) {
        navigator.geolocation.clearWatch(window.__gpsWatchId);
      }
    });

    // DEBUG BASE
    console.log('=== DEBUG GPS INFO ===');
    console.log('GPS disponibile:', !!navigator.geolocation);
    console.log('HTTPS:', location.protocol === 'https:');
    console.log('User Agent:', navigator.userAgent);

    const statusIndicator = document.getElementById('statusIndicator');
    const debugDiv = document.getElementById('debugInfo');
    const avatarToggle = document.getElementById('avatarToggle');
    const visibilityToggle = document.getElementById('visibilityToggle');
    const buildingsToggle = document.getElementById('buildingsToggle');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');
    const loadingProgress = document.getElementById('loadingProgress');

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/streets-v12',
      zoom: 18, 
      pitch: 60, 
      bearing: 0, 
      center: CONFIG.DEFAULT_HOME, 
      antialias: true,
      // üÜï Performance optimizations
      maxTileCacheSize: 50, // ridotto da default
      preserveDrawingBuffer: false,
      refreshExpiredTiles: false
    });

    // Controlli zoom custom
    document.getElementById('zoomIn').onclick = () => map.zoomIn();
    document.getElementById('zoomOut').onclick = () => map.zoomOut();
    document.getElementById('pitchSlider').addEventListener('input', (e) => map.setPitch(parseInt(e.target.value,10)));

    // NavigationControl (solo bussola)
    const navControl = new mapboxgl.NavigationControl({
                        showCompass: true,
                        showZoom: false
                        });

    // Aggiungi il controllo alla mappa
    map.addControl(navControl, 'bottom-right');
    /*map.addControl(new mapboxgl.NavigationControl({ showCompass: true, showZoom: false }), 'bottom-right');*/

    let tb, avatarModel, mixer, currentAnimation = null;
    let use3DAvatar = false;
    let avatarVisible = true;

    let currentLocation = null;
    let previousLocation = null;
    let smoothedLocation = null;
    let avatarMarker;
    let gpsTrackingActive = false;
    let movementTimeout;
    
    window.__lastMoveSpeedKmh = 0;
    
    // Debounce per evitare troppe chiamate
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Throttle per limitare frequenza
    function throttle(func, limit) {
      let inThrottle;
      return function(...args) {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      };
    }

    // üÜï Update debug con throttle (evita troppi aggiornamenti)
    const updateDebugInfo = throttle((extra) => {
      const info = [
        `GPS: ${!!navigator.geolocation ? '‚úÖ' : '‚ùå'}`,
        `HTTPS: ${location.protocol === 'https:' ? '‚úÖ' : '‚ùå'}`,
        `Tracking: ${gpsTrackingActive ? 'üü¢ ON' : 'üî¥ OFF'}`,
        `Avatar: ${avatarVisible ? 'Visibilit√† ON' : 'Visibilit√† OFF'}`,
        smoothedLocation ? `Pos: ${smoothedLocation[0].toFixed(6)}, ${smoothedLocation[1].toFixed(6)}` : 'Pos: N/A',
        `Device: ${/Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent) ? 'üì±' : 'üíª'}`,
        extra ? `Note: ${extra}` : ''
      ].filter(Boolean);
      debugDiv.textContent = info.join('\n');
    }, 1000);

    function showLoading(show, text = 'Caricamento...', progress = 0) {
      if (show) {
        loadingOverlay.classList.add('active');
        loadingText.textContent = text;
        loadingProgress.textContent = progress > 0 ? `${Math.round(progress)}%` : '';
      } else {
        loadingOverlay.classList.remove('active');
      }
    }

    function updateLoadingProgress(progress, text) {
      loadingProgress.textContent = `${Math.round(progress)}%`;
      if (text) loadingText.textContent = text;
    }

    function setStatus(message, autoHide = true, duration = CONFIG.STATUS_AUTO_HIDE_DELAY) {
      statusIndicator.style.display = 'block';
      statusIndicator.style.opacity = '1';
      statusIndicator.textContent = message;
      
      if (autoHide) {
        setTimeout(() => {
          statusIndicator.style.opacity = '0';
          setTimeout(() => {
            statusIndicator.style.display = 'none';
          }, 300);
        }, duration);
      }
    }

    async function initializeLocation() {
      showLoading(true, 'Rilevamento posizione GPS...', 10);
      
      // Check permessi
      try {
        const permissionResult = await navigator.permissions.query({ name: 'geolocation' });
        console.log('Permesso geolocalizzazione:', permissionResult.state);
        updateLoadingProgress(30, 'Verifica permessi...');
      } catch (e) {
        console.warn('Permissions API non disponibile:', e);
      }

      const onSuccess = (pos) => {
        const lng = pos.coords.longitude;
        const lat = pos.coords.latitude;
        const accuracy = pos.coords.accuracy;
        
        console.log('‚úÖ GPS ottenuto:', { lng, lat, accuracy });
        updateLoadingProgress(60, 'Posizione trovata!');
        
        currentLocation = [lng, lat];
        previousLocation = [lng, lat];
        smoothedLocation = [lng, lat];
        
        updateLoadingProgress(80, 'Centraggio mappa...');
        map.flyTo({ 
          center: currentLocation, 
          zoom: 18, 
          pitch: 60, 
          duration: CONFIG.TRANSITION_DURATION 
        });
        
        updateLoadingProgress(90, 'Creazione avatar...');
        createAvatarMarker();
        resumeGPSTracking();
        updateDirectionIndicator();
        enableCompassHeading();
        updateDebugInfo();
        
        updateLoadingProgress(100, 'Completato!');
        setTimeout(() => showLoading(false), 500);
        setStatus('Posizione GPS acquisita!');
      };

      const onError = (err) => {
        console.warn('‚ö†Ô∏è Errore geolocalizzazione:', err.message, err.code);
        
        let errorMsg = 'Errore GPS';
        switch(err.code) {
          case 1: errorMsg = 'Permesso GPS negato'; break;
          case 2: errorMsg = 'Posizione non disponibile'; break;
          case 3: errorMsg = 'Timeout GPS'; break;
        }
        
        updateLoadingProgress(50, `${errorMsg} - uso Milano`);
        
        currentLocation = CONFIG.DEFAULT_HOME;
        previousLocation = [...CONFIG.DEFAULT_HOME];
        smoothedLocation = [...CONFIG.DEFAULT_HOME];
        
        map.flyTo({ 
          center: currentLocation, 
          zoom: 18, 
          pitch: 60, 
          duration: 1200 
        });
        
        createAvatarMarker();
        resumeGPSTracking();
        updateDirectionIndicator();
        enableCompassHeading();
        updateDebugInfo(`Fallback: ${errorMsg}`);
        
        setTimeout(() => showLoading(false), 1000);
        setStatus(`${errorMsg} - Usando posizione di default`, true, 4000);
      };

      // Tentativo di ottenere posizione
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          onSuccess, 
          onError, 
          { 
            enableHighAccuracy: true, 
            timeout: 8000,
            maximumAge: 5000 // accetta cache fino a 5s
          }
        );
      } else {
        onError(new Error('Geolocalizzazione non supportata'));
      }
    }

    // Avvia inizializzazione
    initializeLocation();

    function createAvatarMarker() {
      // Rimuovi marker esistente
      if (avatarMarker) {
        avatarMarker.remove();
        avatarMarker = null;
      }

      const el = document.createElement('div');
      el.className = 'avatar-marker';
      if (!avatarVisible) el.classList.add('avatar-hidden');
      
      avatarMarker = new mapboxgl.Marker(el)
        .setLngLat(smoothedLocation || CONFIG.DEFAULT_HOME)
        .addTo(map);
      
      console.log('‚úÖ Marker 2D creato');
    }

    function initializeThreebox() {
      try {
        tb = new Threebox(map, map.getCanvas().getContext('webgl'), { 
          defaultLights: true,
          realSunlight: true // üÜï luce solare realistica
        });

        map.addLayer({
          id: 'custom-threebox-model',
          type: 'custom',
          renderingMode: '3d',
          onAdd: function() {
            loadAvatar3D();
          },
          render: function(gl, matrix) {
            // üÜï Update performance monitor
            perfMonitor.update();
            
            tb.update();
            if (mixer) mixer.update(CONFIG.ANIMATION_UPDATE_RATE);
          }
        });
      } catch (error) {
        console.error('‚ùå Errore inizializzazione Threebox:', error);
        setStatus('Errore caricamento 3D - uso marker 2D', true, 4000);
        use3DAvatar = false;
        createAvatarMarker();
      }
    }
    
    async function loadAvatar3D(isRetry = false) {
      const avatarUrl = isRetry ? CONFIG.AVATAR_FALLBACK_URL : CONFIG.AVATAR_URL;
      
      showLoading(true, isRetry ? 'Caricamento avatar fallback...' : 'Caricamento avatar 3D...', 0);
      
      const avatarOptions = {
        obj: avatarUrl,
        type: 'gltf',
        scale: { 
          x: CONFIG.AVATAR_SCALE, 
          y: CONFIG.AVATAR_SCALE, 
          z: CONFIG.AVATAR_SCALE 
        },
        units: 'meters',
        rotation: { x: 90, y: 180, z: 0 },
        anchor: 'bottom-left'
      };

      tb.loadObj(avatarOptions, (model) => {
        console.log('‚úÖ Avatar 3D caricato:', avatarUrl);
        avatarModel = model;
        
        updateLoadingProgress(50, 'Setup animazioni...');

        // üÜï MODIFICA 18: GESTIONE ANIMAZIONI MIGLIORATA
        if (model.animations && model.animations.length) {
          console.log(`üìΩÔ∏è ${model.animations.length} animazioni trovate`);
          
          mixer = new THREE.AnimationMixer(model);
          
          // Track per cleanup
          resourceManager.track(mixer, 'stopAllAction');
          
          // Trova e avvia animazione idle
          const idleNames = ['idle', 'breathing_idle', 'standing_idle', 'default'];
          const animationMap = {};
          
          model.animations.forEach(clip => {
            const name = clip.name.toLowerCase();
            animationMap[name] = clip;
            console.log(`  - ${clip.name}: ${clip.duration.toFixed(2)}s`);
          });
          
          // Cerca idle animation
          for (const name of idleNames) {
            if (animationMap[name]) {
              currentAnimation = mixer.clipAction(animationMap[name]);
              currentAnimation.play();
              console.log('‚ñ∂Ô∏è Animazione idle avviata:', name);
              break;
            }
          }
          
          // Fallback: usa prima animazione disponibile
          if (!currentAnimation && model.animations.length > 0) {
            currentAnimation = mixer.clipAction(model.animations[0]);
            currentAnimation.play();
            console.log('‚ñ∂Ô∏è Animazione fallback avviata:', model.animations[0].name);
          }
        } else {
          console.warn('‚ö†Ô∏è Nessuna animazione trovata nel modello');
        }

        updateLoadingProgress(75, 'Posizionamento avatar...');
        
        // üÜï MODIFICA 19: POSIZIONAMENTO CON VALIDAZIONE
        const coords = smoothedLocation || CONFIG.DEFAULT_HOME;
        avatarModel.setCoords([coords[0], coords[1], CONFIG.AVATAR_HEIGHT]);
        
        if (!avatarVisible) {
          avatarModel.visible = false;
        }
        
        tb.add(avatarModel);
        
        // üÜï Track per cleanup
        resourceManager.track(avatarModel);

        updateLoadingProgress(100, 'Avatar pronto!');
        showLoading(false);
        setStatus('Avatar 3D caricato con successo!');
        
        // üÜï Log info modello
        logModelInfo(model);
        
      }, (progress) => {
        // üÜï MODIFICA 20: PROGRESS CALLBACK
        const percent = (progress.loaded / progress.total) * 100;
        updateLoadingProgress(percent, 'Download avatar...');
        console.log(`üì• Download: ${percent.toFixed(0)}%`);
      }, (error) => {
        // üÜï MODIFICA 21: GESTIONE ERRORI CON RETRY
        console.error('‚ùå Errore caricamento avatar:', error);
        
        if (!isRetry) {
          console.log('üîÑ Tentativo con avatar fallback...');
          setTimeout(() => loadAvatar3D(true), 1000);
        } else {
          showLoading(false);
          setStatus('Errore caricamento avatar - uso marker 2D', true, 4000);
          use3DAvatar = false;
          createAvatarMarker();
          
          avatarToggle.textContent = 'üë§ 2D';
          avatarToggle.style.background = 'white';
          avatarToggle.style.color = 'black';
        }
      });
    }

    function logModelInfo(model) {
      console.group('üìä Dettagli Modello 3D');
      
      if (model.scene) {
        let vertCount = 0, faceCount = 0, meshCount = 0;
        let textureCount = 0, textureMemory = 0;
        
        model.scene.traverse((child) => {
          if (child.isMesh) {
            meshCount++;
            
            if (child.geometry) {
              if (child.geometry.attributes.position) {
                vertCount += child.geometry.attributes.position.count;
              }
              if (child.geometry.index) {
                faceCount += child.geometry.index.count / 3;
              }
            }
            
            if (child.material) {
              const mat = Array.isArray(child.material) ? child.material : [child.material];
              mat.forEach(m => {
                if (m.map && m.map.image) {
                  textureCount++;
                  const img = m.map.image;
                  const bytes = (img.width || 512) * (img.height || 512) * 4;
                  textureMemory += bytes;
                }
              });
            }
          }
        });
        
        console.log(`Meshes: ${meshCount}`);
        console.log(`Vertici: ${vertCount.toLocaleString()}`);
        console.log(`Facce: ${Math.round(faceCount).toLocaleString()}`);
        console.log(`Texture: ${textureCount} (~${(textureMemory/1048576).toFixed(2)} MB)`);
      }
      
      if (model.animations) {
        console.log(`\nAnimazioni: ${model.animations.length}`);
        model.animations.forEach((anim, i) => {
          console.log(`  ${i + 1}. ${anim.name || 'Unnamed'} - ${anim.duration.toFixed(2)}s (${anim.tracks.length} tracks)`);
        });
      }
      
      console.groupEnd();
    }

    visibilityToggle.addEventListener('click', () => {
      avatarVisible = !avatarVisible;
      
      if (avatarVisible) {
        visibilityToggle.textContent = 'Visibilit√† ON';
        visibilityToggle.classList.remove('hidden');
        
        if (use3DAvatar && avatarModel) {
            avatarModel.setObjectScale(CONFIG.AVATAR_SCALE, CONFIG.AVATAR_SCALE, CONFIG.AVATAR_SCALE);
          
            // Prova anche traverse di THREE.js
            if (avatarModel.scene) {
                avatarModel.scene.traverse((child) => {
                if (child.isMesh) {
                    child.visible = true;
                }
                });
            }

          /* avatarModel.visible = true;*/
        } else if (avatarMarker) {
          avatarMarker.getElement().classList.remove('avatar-hidden');
        }
        
        setStatus('Avatar visibile');
      } else {
        visibilityToggle.textContent = 'Visibilit√† OFF';
        visibilityToggle.classList.add('hidden');
        
        if (use3DAvatar && avatarModel) {
            avatarModel.setObjectScale(0.001, 0.001, 0.001);
            if (avatarModel.scene) {
                avatarModel.scene.traverse((child) => {
                if (child.isMesh) {
                    child.visible = false;
                }
                });
            }
        /*    if (avatarModel.scene) {                
                avatarModel.scene.visible = false;
                }
                avatarModel.visible = false;
        */
        } else if (avatarMarker) {
          avatarMarker.getElement().classList.add('avatar-hidden');
        }
        
        setStatus('Avatar nascosto');
      }
      
      updateDebugInfo();
    });

    avatarToggle.addEventListener('click', () => {
      if (!use3DAvatar) {
        // Passa a 3D
        setStatus('Attivazione avatar 3D...', false);
        
        // Rimuovi marker 2D
        if (avatarMarker) {
          avatarMarker.remove();
          avatarMarker = null;
        }
        
        // Attiva layer 3D
        if (map.getLayer('custom-threebox-model')) {
          map.setLayoutProperty('custom-threebox-model', 'visibility', 'visible');
          
          if (avatarModel) {
            const coords = smoothedLocation || CONFIG.DEFAULT_HOME;
            avatarModel.setCoords([coords[0], coords[1], CONFIG.AVATAR_HEIGHT]);
            avatarModel.visible = avatarVisible;
          }
          setStatus('Avatar 3D attivo!');
        } else {
          initializeThreebox();
        }
        
        use3DAvatar = true;
        avatarToggle.textContent = 'üë§ 3D';
        avatarToggle.style.background = '#4CAF50';
        avatarToggle.style.color = '#fff';
        
      } else {
        // Passa a 2D
        if (map.getLayer('custom-threebox-model')) {
          map.setLayoutProperty('custom-threebox-model', 'visibility', 'none');
        }
        
        createAvatarMarker();
        use3DAvatar = false;
        
        avatarToggle.textContent = 'üë§ 2D';
        avatarToggle.style.background = 'white';
        avatarToggle.style.color = 'black';
        
        setStatus('Avatar 2D attivo');
      }
    });

    let buildingsVisible = true;
    buildingsToggle.addEventListener('click', () => {
      buildingsVisible = !buildingsVisible;
      
      if (map.getLayer('3d-buildings')) {
        map.setLayoutProperty('3d-buildings', 'visibility', buildingsVisible ? 'visible' : 'none');
        buildingsToggle.textContent = buildingsVisible ? 'üèôÔ∏è 3D On' : 'üèôÔ∏è 3D Off';
        setStatus(buildingsVisible ? 'Edifici 3D visibili' : 'Edifici 3D nascosti');
      }
    });

    function geographicBearing(from, to) {
      const [lon1, lat1] = from.map(v => v * Math.PI / 180);
      const [lon2, lat2] = to.map(v => v * Math.PI / 180);
      const dLon = lon2 - lon1;
      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
      let brng = Math.atan2(y, x) * 180 / Math.PI;
      return (brng + 360) % 360;
    }

    function calculateDistance(a, b) {
      if (!a || !b) return 0;
      
      const R = 6371e3; // Earth radius in meters
      const [lon1, lat1] = a.map(v => v * Math.PI / 180);
      const [lon2, lat2] = b.map(v => v * Math.PI / 180);
      const dLat = lat2 - lat1;
      const dLon = lon2 - lon1;
      const h = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(h));
    }

    function lerp(a, b, t) { 
      return a + (b - a) * t; 
    }

    // üÜï MODIFICA 27: SMOOTHING CON VALIDAZIONE
    function smoothTo(target) {
      if (!target || target.length !== 2) {
        console.warn('‚ö†Ô∏è Target invalido per smoothing');
        return;
      }
      
      if (!smoothedLocation) {
        smoothedLocation = [...target];
        return;
      }
      
      smoothedLocation = [
        lerp(smoothedLocation[0], target[0], CONFIG.EMA_ALPHA),
        lerp(smoothedLocation[1], target[1], CONFIG.EMA_ALPHA)
      ];
    }

    const updateMovementUI = throttle((distance, bearing) => {
      const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
      const idx = Math.round(bearing / 22.5) % 16;
      const direction = dirs[idx];

      const now = performance.now();
      if (!window.__lastMoveTime) {
        window.__lastMoveTime = now;
        window.__lastMoveDist = 0;
      }
      
      const dt = Math.max(0.1, (now - window.__lastMoveTime) / 1000);
      const speed = distance / dt;
      const kmh = speed * 3.6;

      window.__lastMoveSpeedKmh = kmh;

      const dirEl = document.getElementById('directionIndicator');
      const isMobile = window.innerWidth <= 768;
      
      if (isMobile) {
        dirEl.textContent = `${direction} ${Math.round(bearing)}¬∞`;
        map.removeControl(navControl);
      } else {
        dirEl.textContent = `${direction} ${Math.round(bearing)}¬∞ ‚Ä¢ ${kmh.toFixed(1)} km/h`;
        map.addControl(navControl, 'bottom-right');
      }
      
      window.__lastMoveTime = now;
    }, 500); // Update ogni 500ms max

    function startWalkingAnimation() {
      if (!avatarModel || !mixer) return;
      
      const walkNames = ['walking', 'walk', 'run', 'running', 'locomotion'];
      
      for (const clip of (avatarModel.animations || [])) {
        const n = clip.name.toLowerCase();
        if (walkNames.some(s => n.includes(s))) {
          if (currentAnimation) {
            currentAnimation.fadeOut(0.25);
          }
          currentAnimation = mixer.clipAction(clip);
          currentAnimation.reset().fadeIn(0.25).play();
          console.log('üö∂ Walking animation:', clip.name);
          return;
        }
      }
    }

    function startIdleAnimation() {
      if (!avatarModel || !mixer) return;
      
      const idleNames = ['idle', 'breathing_idle', 'standing_idle', 'default'];
      
      for (const clip of (avatarModel.animations || [])) {
        const n = clip.name.toLowerCase();
        if (idleNames.some(s => n.includes(s))) {
          if (currentAnimation) {
            currentAnimation.fadeOut(0.25);
          }
          currentAnimation = mixer.clipAction(clip);
          currentAnimation.reset().fadeIn(0.25).play();
          console.log('üßç Idle animation:', clip.name);
          return;
        }
      }
      
      // Fallback alla prima animazione
      if ((avatarModel.animations || []).length) {
        if (currentAnimation) {
          currentAnimation.fadeOut(0.25);
        }
        currentAnimation = mixer.clipAction(avatarModel.animations[0]);
        currentAnimation.reset().fadeIn(0.25).play();
      }
    }

    function applyAvatarTransform(newLoc) {
      if (!newLoc || newLoc.length !== 2) {
        console.warn('‚ö†Ô∏è Posizione invalida per transform');
        return;
      }
      
      smoothTo(newLoc);
      
      const distance = calculateDistance(currentLocation, newLoc);
      const bearing = geographicBearing(previousLocation || currentLocation, newLoc);

      if (use3DAvatar && avatarModel) {
        // Posizionamento
        avatarModel.setCoords([
          smoothedLocation[0], 
          smoothedLocation[1], 
          CONFIG.AVATAR_HEIGHT
        ]);
        
        // ROTAZIONE CORRETTA (solo Y axis)
        const yDeg = -(bearing - 90);
        avatarModel.setRotation({ x: 90, y: yDeg, z: 0 });

        // Animazione basata su movimento
        if (mixer && distance > CONFIG.GPS_MIN_MOVEMENT) {
          clearTimeout(movementTimeout);
          startWalkingAnimation();
          movementTimeout = setTimeout(() => {
            startIdleAnimation();
          }, CONFIG.IDLE_TIMEOUT);
        }
      } else if (avatarMarker) {
        avatarMarker.setLngLat(smoothedLocation);
      }

      updateMovementUI(distance, bearing);
      previousLocation = currentLocation;
      currentLocation = newLoc;
    }

    function enableCompassHeading() {
      let lastHeading = null;
      const HEADING_THRESHOLD = 5; // gradi minimo cambiamento
      
      function onHeading(heading) {
        if (use3DAvatar && avatarModel && typeof heading === 'number') {
          // Applica solo se cambiamento significativo
          if (lastHeading === null || Math.abs(heading - lastHeading) > HEADING_THRESHOLD) {
            const yDeg = -(heading - 90);
            avatarModel.setRotation({ x: 90, y: yDeg, z: 0 });
            lastHeading = heading;
          }
        }
      }

      // iOS - richiede permesso
      if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
        avatarToggle.addEventListener('click', async () => {
          try {
            const res = await DeviceOrientationEvent.requestPermission();
            if (res === 'granted') {
              window.addEventListener('deviceorientation', (e) => {
                const h = e.webkitCompassHeading ?? (360 - (e.alpha || 0));
                onHeading(h);
              });
              console.log('‚úÖ Bussola iOS attivata');
            }
          } catch (err) {
            console.warn('‚ö†Ô∏è Permesso bussola negato:', err);
          }
        }, { once: true });
      } 
      // Android / altri dispositivi
      else if (window.DeviceOrientationEvent) {
        const eventType = 'deviceorientationabsolute' in window ? 
          'deviceorientationabsolute' : 'deviceorientation';
        
        window.addEventListener(eventType, (e) => {
          if (e.absolute && typeof e.alpha === 'number') {
            const h = 360 - e.alpha;
            onHeading(h);
          }
        });
        console.log('‚úÖ Bussola Android attivata');
      }
    }

    function handleGPS(pos) {
      const { longitude: lng, latitude: lat, accuracy, speed, heading } = pos.coords;
      const newLoc = [lng, lat];
      
      // üÜï Filtra fix imprecisi
      if (accuracy && accuracy > CONFIG.GPS_ACCURACY_THRESHOLD) {
        console.warn(`‚ö†Ô∏è GPS accuracy troppo bassa: ${accuracy.toFixed(0)}m`);
        updateDebugInfo(`Acc. bassa: ${accuracy.toFixed(0)}m`);
        return;
      }

      // GPS heading quando in movimento
      if (typeof heading === 'number' && !Number.isNaN(heading) && speed && speed > 0.5) {
        if (use3DAvatar && avatarModel) {
          const yDeg = -(heading - 90);
          avatarModel.setRotation({ x: 90, y: yDeg, z: 0 });
        }
      }

      // Calcola distanza
      const d = calculateDistance(smoothedLocation || currentLocation, newLoc);
      
      // Applica transform solo se movimento significativo
      if (d > CONFIG.GPS_MIN_MOVEMENT) {
        applyAvatarTransform(newLoc);
        
        // Aggiorna mappa se movimento grande
        if (d > CONFIG.GPS_UPDATE_DISTANCE) {
          map.easeTo({ center: newLoc, duration: 1000 });
        }
      }
      
      // Update debug
      const speedKmh = speed ? (speed * 3.6).toFixed(1) : '0.0';
      updateDebugInfo(`Vel: ${speedKmh} km/h | Acc: ${accuracy?.toFixed(0) || 'N/A'}m`);
    }

    const gpsToggleBtn = document.getElementById('gpsToggle');
    gpsToggleBtn.addEventListener('click', () => {
      if (gpsTrackingActive) {
        stopGPSTracking();
      } else {
        resumeGPSTracking();
      }
    });

    function stopGPSTracking() {
      if (window.__gpsWatchId) {
        navigator.geolocation.clearWatch(window.__gpsWatchId);
        window.__gpsWatchId = null;
      }
      
      gpsTrackingActive = false;
      
      setStatus('GPS tracking disattivato');
      gpsToggleBtn.classList.remove('active');
      gpsToggleBtn.textContent = 'üìç GPS OFF';
      updateDebugInfo('GPS OFF');
    }

    function resumeGPSTracking() {
      if (!navigator.geolocation) {
        setStatus('GPS non supportato', true, 3000);
        return;
      }

      gpsTrackingActive = true;
      gpsToggleBtn.classList.add('active');
      gpsToggleBtn.textContent = 'üìç GPS ON';
      setStatus('GPS tracking attivo');

      // üÜï Prima ottieni posizione corrente
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lng = pos.coords.longitude;
          const lat = pos.coords.latitude;
          
          if (!currentLocation) {
            currentLocation = [lng, lat];
            previousLocation = [lng, lat];
            smoothedLocation = [lng, lat];
            
            map.flyTo({ 
              center: currentLocation, 
              zoom: 18, 
              pitch: 60, 
              duration: CONFIG.TRANSITION_DURATION 
            });
            
            if (!avatarMarker && !avatarModel) {
              createAvatarMarker();
            }
          }
          
          updateDebugInfo('GPS fix iniziale ottenuto');
        },
        (err) => console.warn('‚ö†Ô∏è Errore getCurrentPosition:', err),
        { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
      );

      // üÜï Poi attiva tracking continuo
      const opts = {
        enableHighAccuracy: true,
        maximumAge: 1000,
        timeout: 8000
      };

      window.__gpsWatchId = navigator.geolocation.watchPosition(
        handleGPS,
        (err) => {
          console.error('‚ùå Errore GPS tracking:', err.message);
          setStatus(`Errore GPS: ${err.message}`, true, 3000);
          updateDebugInfo(`GPS Err: ${err.code}`);
        },
        opts
      );
      
      console.log('‚úÖ GPS tracking avviato');
    }

    document.getElementById('goHome').addEventListener('click', () => {
      const target = (gpsTrackingActive && smoothedLocation) ? 
        smoothedLocation : CONFIG.DEFAULT_HOME;
      
      const zoom = (gpsTrackingActive && smoothedLocation) ? 18 : 12;
      const pitch = (gpsTrackingActive && smoothedLocation) ? 60 : 45;
      
      map.flyTo({
        center: target,
        zoom: zoom,
        pitch: pitch,
        speed: 0.8,
        curve: 1.5
      });
      
      setStatus('Centrato su posizione');
    });

    const directionIndicator = document.getElementById('directionIndicator');
    
    const updateDirectionIndicator = throttle(() => {
      const b = ((map.getBearing() % 360) + 360) % 360;
      const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      const idx = Math.round(b / 45) % 8;
      const isMobile = window.innerWidth <= 768;
      const kmh = window.__lastMoveSpeedKmh && !isMobile ? 
        ` ‚Ä¢ ${window.__lastMoveSpeedKmh.toFixed(1)} km/h` : '';
      directionIndicator.textContent = `${dirs[idx]} ${Math.round(b)}¬∞${kmh}`;
    }, 250);

    map.on('rotate', updateDirectionIndicator);
    window.addEventListener('resize', debounce(updateDirectionIndicator, 500));

    map.on('load', () => {
      console.log('üó∫Ô∏è Mappa caricata');

      const layers = map.getStyle().layers;
      let labelLayerId;
      for (const layer of layers) {
        if (layer.type === 'symbol' && layer.layout && layer.layout['text-field']) {
          labelLayerId = layer.id;
          break;
        }
      }

      // üÜï Edifici 3D con configurazione ottimizzata
      map.addLayer(
        {
          id: '3d-buildings',
          source: 'composite',
          'source-layer': 'building',
          filter: ['==', 'extrude', 'true'],
          type: 'fill-extrusion',
          minzoom: 15,
          paint: {
            'fill-extrusion-color': [
              'interpolate',
              ['linear'],
              ['get', 'height'],
              0, '#aaa',
              50, '#999',
              100, '#888'
            ],
            'fill-extrusion-height': ['get', 'height'],
            'fill-extrusion-base': ['get', 'min_height'],
            'fill-extrusion-opacity': 0.6
          }
        },
        labelLayerId
      );

      // üÜï Luce ottimizzata
      map.setLight({
        anchor: 'map',
        color: '#ffffff',
        intensity: 0.5,
        position: [1.15, 210, 30]
      });

      console.log('‚úÖ Edifici 3D configurati');
    });

    document.addEventListener('keydown', (e) => {
      switch(e.key.toLowerCase()) {
        case 'p': // Performance monitor
          perfMonitor.toggle();
          break;
        case 'h': // Home
          document.getElementById('goHome').click();
          break;
        case 'g': // GPS toggle
          gpsToggleBtn.click();
          break;
        case 'v': // Visibility toggle
          visibilityToggle.click();
          break;
        case 'a': // Avatar 2D/3D
          avatarToggle.click();
          break;
        case 'b': // Buildings
          buildingsToggle.click();
          break;
      }
    });

    console.log('‚å®Ô∏è Shortcuts: P=Perf, H=Home, G=GPS, V=Visibility, A=Avatar, B=Buildings');

    setInterval(() => {
      if (gpsTrackingActive) {
        updateDebugInfo();
      }
    }, 5000);

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        console.log('‚è∏Ô∏è Tab nascosta - pausa animazioni');
        // Pausa animazioni per risparmiare batteria
        if (mixer) {
          mixer.timeScale = 0;
        }
        // Riduce aggiornamenti GPS
        if (gpsTrackingActive && window.__gpsWatchId) {
          // Non stoppiamo GPS ma riduciamo priority
          console.log('üîã Modalit√† risparmio energetico attiva');
        }
      } else {
        console.log('‚ñ∂Ô∏è Tab visibile - riprendi animazioni');
        // Riprendi animazioni
        if (mixer) {
          mixer.timeScale = 1;
        }
      }
    });

    window.addEventListener('error', (event) => {
      console.error('‚ùå Errore globale:', event.error);
      
      // Recovery automatico per errori comuni
      if (event.error && event.error.message) {
        const msg = event.error.message.toLowerCase();
        
        // WebGL context loss
        if (msg.includes('webgl') || msg.includes('context')) {
          setStatus('Errore grafico - ricarica pagina', false);
          console.error('üí• WebGL context perso - serve reload');
        }
        
        // Out of memory
        if (msg.includes('memory')) {
          console.error('üíæ Memoria insufficiente');
          setStatus('Memoria insufficiente - libero risorse', true, 4000);
          resourceManager.cleanup();
        }
      }
    });

    // WebGL context lost handler
    const canvas = map.getCanvas();
    canvas.addEventListener('webglcontextlost', (event) => {
      event.preventDefault();
      console.error('üí• WebGL context perso!');
      setStatus('Errore grafico - ricaricare la pagina', false);
    }, false);

    canvas.addEventListener('webglcontextrestored', () => {
      console.log('‚úÖ WebGL context ripristinato');
      setStatus('Grafica ripristinata', true, 2000);
    }, false);

    window.addEventListener('online', () => {
      console.log('üåê Connessione ripristinata');
      setStatus('Connessione ristabilita', true, 2000);
      
      // Riprendi GPS se era attivo
      if (gpsTrackingActive && !window.__gpsWatchId) {
        resumeGPSTracking();
      }
    });

    window.addEventListener('offline', () => {
      console.log('üì° Connessione persa');
      setStatus('Modalit√† offline - mappe in cache', true, 4000);
    });

    window.addEventListener('orientationchange', debounce(() => {
      console.log('üì± Orientamento cambiato');
      
      // Forza ridisegno mappa
      setTimeout(() => {
        map.resize();
        updateDirectionIndicator();
      }, 200);
    }, 300));

    if ('getBattery' in navigator) {
      navigator.getBattery().then((battery) => {
        console.log(`üîã Batteria: ${(battery.level * 100).toFixed(0)}%`);
        
        // Modalit√† risparmio energetico se batteria bassa
        function checkBattery() {
          if (battery.level < 0.2 && !battery.charging) {
            console.warn('‚ö†Ô∏è Batteria bassa - riduco aggiornamenti');
            
            // Riduce qualit√† se batteria < 20%
            if (use3DAvatar && avatarModel) {
              // Potresti ridurre qualit√† rendering qui
              setStatus('Batteria bassa - modalit√† risparmio', true, 3000);
            }
          }
        }
        
        battery.addEventListener('levelchange', checkBattery);
        battery.addEventListener('chargingchange', checkBattery);
        
        checkBattery();
      }).catch(err => {
        console.log('Battery API non disponibile:', err);
      });
    }
    console.group('üìä Statistiche App');
    console.log('Device:', /Mobile|Android|iPhone|iPad/i.test(navigator.userAgent) ? 'Mobile' : 'Desktop');
    console.log('Platform:', navigator.platform);
    console.log('Screen:', `${window.screen.width}x${window.screen.height}`);
    console.log('Viewport:', `${window.innerWidth}x${window.innerHeight}`);
    console.log('DPR:', window.devicePixelRatio);
    console.log('Touch:', 'ontouchstart' in window ? 'Si' : 'No');
    console.log('WebGL:', document.createElement('canvas').getContext('webgl') ? 'Supportato' : 'Non supportato');
    console.log('Memoria:', performance.memory ? `${(performance.memory.jsHeapSizeLimit / 1048576).toFixed(0)} MB` : 'N/A');
    console.groupEnd();
  </script>
</body>
</html>
